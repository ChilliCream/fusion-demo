schema {
  query: Query
  subscription: Subscription
}

type Query
  @fusion__type(schema: CATALOG)
  @fusion__type(schema: REVIEWS) {
  brandById(id: Int!
    @fusion__inputField(schema: CATALOG)): Brand
    @fusion__field(schema: CATALOG)
  productById(id: Int!
    @fusion__inputField(schema: CATALOG)): Product
    @fusion__field(schema: CATALOG)
  products("Returns the elements in the list that come after the specified cursor." after: String
    @fusion__inputField(schema: CATALOG) "Returns the elements in the list that come before the specified cursor." before: String
    @fusion__inputField(schema: CATALOG) "Returns the first _n_ elements from the list." first: Int
    @fusion__inputField(schema: CATALOG) "Returns the last _n_ elements from the list." last: Int
    @fusion__inputField(schema: CATALOG) where: ProductFilterInput
    @fusion__inputField(schema: CATALOG)): ProductsConnection
    @fusion__field(schema: CATALOG)
}

type Subscription
  @fusion__type(schema: CATALOG) {
  onBrandAdded: Brand!
    @fusion__field(schema: CATALOG)
}

type Brand
  @fusion__type(schema: CATALOG)
  @fusion__lookup(schema: CATALOG, key: "id", field: "brandById(id: Int!): Brand", map: [ "id" ], path: null) {
  id: Int!
    @fusion__field(schema: CATALOG)
  name: String!
    @fusion__field(schema: CATALOG)
  products: [Product!]!
    @fusion__field(schema: CATALOG)
}

"Information about pagination in a connection."
type PageInfo
  @fusion__type(schema: CATALOG) {
  "When paginating forwards, the cursor to continue."
  endCursor: String
    @fusion__field(schema: CATALOG)
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
    @fusion__field(schema: CATALOG)
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
    @fusion__field(schema: CATALOG)
  "When paginating backwards, the cursor to continue."
  startCursor: String
    @fusion__field(schema: CATALOG)
}

type Product
  @fusion__type(schema: CATALOG)
  @fusion__type(schema: REVIEWS)
  @fusion__lookup(schema: CATALOG, key: "id", field: "productById(id: Int!): Product", map: [ "id" ], path: null)
  @fusion__lookup(schema: REVIEWS, key: "id", field: "productById(id: Int!): Product!", map: [ "id" ], path: null) {
  availableStock: Int!
    @fusion__field(schema: CATALOG)
  brand: Brand
    @fusion__field(schema: CATALOG)
  brandId: Int!
    @fusion__field(schema: CATALOG)
  description: String
    @fusion__field(schema: CATALOG)
  id: Int!
    @fusion__field(schema: CATALOG)
    @fusion__field(schema: REVIEWS)
  imageFileName: String
    @fusion__field(schema: CATALOG)
  maxStockThreshold: Int!
    @fusion__field(schema: CATALOG)
  name: String!
    @fusion__field(schema: CATALOG)
  nameAndId: String!
    @fusion__field(schema: REVIEWS)
    @fusion__requires(schema: REVIEWS, requirements: "name", field: "nameAndId(name: String!): String!", map: [ "name" ])
  onReorder: Boolean!
    @fusion__field(schema: CATALOG)
  price: Decimal!
    @fusion__field(schema: CATALOG)
  restockThreshold: Int!
    @fusion__field(schema: CATALOG)
  type: ProductType
    @fusion__field(schema: CATALOG)
  typeId: Int!
    @fusion__field(schema: CATALOG)
}

"A connection to a list of items."
type ProductsConnection
  @fusion__type(schema: CATALOG) {
  "A list of edges."
  edges: [ProductsEdge!]
    @fusion__field(schema: CATALOG)
  "A flattened list of the nodes."
  nodes: [Product!]
    @fusion__field(schema: CATALOG)
  "Information to aid in pagination."
  pageInfo: PageInfo!
    @fusion__field(schema: CATALOG)
}

"An edge in a connection."
type ProductsEdge
  @fusion__type(schema: CATALOG) {
  "A cursor for use in pagination."
  cursor: String!
    @fusion__field(schema: CATALOG)
  "The item at the end of the edge."
  node: Product!
    @fusion__field(schema: CATALOG)
}

type ProductType
  @fusion__type(schema: CATALOG) {
  id: Int!
    @fusion__field(schema: CATALOG)
  name: String!
    @fusion__field(schema: CATALOG)
  products: [Product!]!
    @fusion__field(schema: CATALOG)
}

input DecimalOperationFilterInput
  @fusion__type(schema: CATALOG) {
  eq: Decimal
    @fusion__inputField(schema: CATALOG)
  gt: Decimal
    @fusion__inputField(schema: CATALOG)
  gte: Decimal
    @fusion__inputField(schema: CATALOG)
  in: [Decimal]
    @fusion__inputField(schema: CATALOG)
  lt: Decimal
    @fusion__inputField(schema: CATALOG)
  lte: Decimal
    @fusion__inputField(schema: CATALOG)
  neq: Decimal
    @fusion__inputField(schema: CATALOG)
  ngt: Decimal
    @fusion__inputField(schema: CATALOG)
  ngte: Decimal
    @fusion__inputField(schema: CATALOG)
  nin: [Decimal]
    @fusion__inputField(schema: CATALOG)
  nlt: Decimal
    @fusion__inputField(schema: CATALOG)
  nlte: Decimal
    @fusion__inputField(schema: CATALOG)
}

input ProductFilterInput
  @fusion__type(schema: CATALOG) {
  and: [ProductFilterInput!]
    @fusion__inputField(schema: CATALOG)
  or: [ProductFilterInput!]
    @fusion__inputField(schema: CATALOG)
  price: DecimalOperationFilterInput
    @fusion__inputField(schema: CATALOG)
}

enum fusion__Schema {
  CATALOG
  REVIEWS
}

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal
  @fusion__type(schema: CATALOG)

scalar fusion__FieldDefinition

scalar fusion__FieldSelectionMap

scalar fusion__FieldSelectionPath

scalar fusion__FieldSelectionSet

"The @fusion__enumValue directive specifies which source schema provides an enum value."
directive @fusion__enumValue("The name of the source schema that provides the specified enum value." schema: fusion__Schema!) repeatable on ENUM_VALUE

"The @fusion__field directive specifies which source schema provides a field in a composite type and what execution behavior it has."
directive @fusion__field("Indicates that this field is only partially provided and must be combined with `provides`." partial: Boolean! = false "A selection set of fields this field provides in the composite schema." provides: fusion__FieldSelectionSet "The name of the source schema that originally provided this field." schema: fusion__Schema! "The field type in the source schema if it differs in nullability or structure." sourceType: String) repeatable on FIELD_DEFINITION

"The @fusion__implements directive specifies on which source schema an interface is implemented by an object or interface type."
directive @fusion__implements("The name of the interface type." interface: String! "The name of the source schema on which the annotated type implements the specified interface." schema: fusion__Schema!) repeatable on OBJECT | INTERFACE

"The @fusion__inputField directive specifies which source schema provides an input field in a composite input type."
directive @fusion__inputField("The name of the source schema that originally provided this input field." schema: fusion__Schema! "The field type in the source schema if it differs in nullability or structure." sourceType: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

"The @fusion__lookup directive specifies how the distributed executor can resolve data for an entity type from a source schema by a stable key."
directive @fusion__lookup("The GraphQL field definition in the source schema that can be used to look up the entity." field: fusion__FieldDefinition! "A selection set on the annotated entity type that describes the stable key for the lookup." key: fusion__FieldSelectionSet! "The map describes how the key values are resolved from the annotated entity type." map: [fusion__FieldSelectionMap!]! "The path to the lookup field relative to the Query type." path: fusion__FieldSelectionPath "The name of the source schema where the annotated entity type can be looked up from." schema: fusion__Schema!) repeatable on OBJECT | INTERFACE | UNION

"The @fusion__requires directive specifies if a field has requirements on a source schema."
directive @fusion__requires("The GraphQL field definition in the source schema that this field depends on." field: fusion__FieldDefinition! "The map describes how the argument values for the source schema are resolved from the arguments of the field exposed in the client-facing composite schema and from required data relative to the current type." map: [fusion__FieldSelectionMap]! "A selection set on the annotated field that describes its requirements." requirements: fusion__FieldSelectionSet! "The name of the source schema where this field has requirements to data on other source schemas." schema: fusion__Schema!) repeatable on FIELD_DEFINITION

"The @fusion__type directive specifies which source schemas provide parts of a composite type."
directive @fusion__type("The name of the source schema that originally provided part of the annotated type." schema: fusion__Schema!) repeatable on SCALAR | OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT

"The @fusion__unionMember directive specifies which source schema provides a member type of a union."
directive @fusion__unionMember("The name of the member type." member: String! "The name of the source schema that provides the specified member type." schema: fusion__Schema!) repeatable on UNION
